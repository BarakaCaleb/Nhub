"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _types = require("../codec/types");

var _fs = _interopRequireDefault(require("fs"));

var _util = require("@plugnet/util");

var _src = _interopRequireDefault(require("../../../type-jsonrpc/src"));

var _create = require("../codec/create");

var codecClasses = _interopRequireWildcard(require("../codec"));

var _AbstractInt = _interopRequireDefault(require("../codec/AbstractInt"));

var _UInt = _interopRequireDefault(require("../codec/UInt"));

var _Vec = _interopRequireDefault(require("../codec/Vec"));

var definitions = _interopRequireWildcard(require("../interfaces/definitions"));

var primitiveClasses = _interopRequireWildcard(require("../primitive"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const HEADER = '// Auto-generated via `yarn build:interfaces`, do not edit\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\n';
const FOOTER = '\n'; // Maps the types as found to the source location. This is used to generate the
// imports in the output file, dep-duped and sorted

function setImports(_ref, types) {
  let {
    codecTypes,
    localTypes,
    ownTypes,
    primitiveTypes,
    typesTypes
  } = _ref;
  types.forEach(type => {
    if (ownTypes.includes(type)) {// do nothing
    } else if (['Codec', 'IExtrinsic'].includes(type)) {
      typesTypes[type] = true;
    } else if (codecClasses[type]) {
      codecTypes[type] = true;
    } else if (primitiveClasses[type] || type === 'Metadata') {
      primitiveTypes[type] = true;
    } else {
      // find this module inside the exports from the rest
      const [moduleName] = Object.entries(definitions).find((_ref2) => {
        let [, {
          types
        }] = _ref2;
        return Object.keys(types).includes(type);
      }) || [null];

      if (moduleName) {
        localTypes[moduleName][type] = true;
      }
    }
  });
} // See if a class is child of another class
// FIMXE This could go in util some day


function isChildClass(Parent, Child) {
  // https://stackoverflow.com/questions/30993434/check-if-a-constructor-inherits-another-in-es6/30993664
  // eslint-disable-next-line no-prototype-builtins
  return Parent === Child || Parent.isPrototypeOf(Child);
}

function isCompactEncodable(Child) {
  return isChildClass(_UInt.default, Child);
} // helper to generate a `export interface <Name> extends <Base> {<Body>}


function exportInterface() {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let base = arguments.length > 1 ? arguments[1] : undefined;
  let body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "/** ".concat(base, " */\nexport interface ").concat(name, " extends ").concat(base, " {").concat(body.length ? '\n' : '').concat(body, "}");
} // helper to create an `export <Name> = <Base>`


function exportType() {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let base = arguments.length > 1 ? arguments[1] : undefined;
  return "/** ".concat(base, " */\nexport type ").concat(name, " = ").concat(base, ";");
} // helper to generate a `readonly <Name>: <Type>;` getter


function createGetter() {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let type = arguments.length > 1 ? arguments[1] : undefined;
  let imports = arguments.length > 2 ? arguments[2] : undefined;
  let doc = arguments.length > 3 ? arguments[3] : undefined;
  setImports(imports, [type]);
  return "  /** ".concat(doc || type, " */\n  readonly ").concat(name, ": ").concat(type, ";\n");
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function errorUnhandled(def, imports) {
  throw new Error("Generate: ".concat(name, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
}

function tsCompact(_ref3, imports) {
  let {
    name: compactName,
    sub
  } = _ref3;
  const def = sub;
  setImports(imports, ['Compact']);

  switch (def.info) {
    case _types.TypeDefInfo.Plain:
      setImports(imports, [def.type]);
      return exportType(compactName, "Compact<".concat(def.type, ">"));

    default:
      throw new Error("Enum: ".concat(compactName, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
  }
}

function tsEnum(_ref4, imports) {
  let {
    name: enumName,
    sub
  } = _ref4;
  setImports(imports, ['Enum']);
  const keys = sub.map((_ref5, index) => {
    let {
      info,
      name = '',
      type
    } = _ref5;
    const getter = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(name.replace(' ', '_')));
    const [enumType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), createGetter("as".concat(getter), type, imports)];
    const isGetter = createGetter("is".concat(getter), 'boolean', imports, "".concat(index, ":: ").concat(name).concat(enumType));

    switch (info) {
      case _types.TypeDefInfo.Plain:
      case _types.TypeDefInfo.Vec:
        return "".concat(isGetter).concat(asGetter);

      default:
        throw new Error("Enum: ".concat(enumName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
    }
  });
  return exportInterface(enumName, 'Enum', keys.join(''));
}

function tsOption(_ref6, imports) {
  let {
    name: optionName,
    sub
  } = _ref6;
  const def = sub;
  setImports(imports, ['Option']);

  switch (def.info) {
    case _types.TypeDefInfo.Plain:
      setImports(imports, [def.type]);
      return exportType(optionName, "Option<".concat(def.type, ">"));

    default:
      throw new Error("Enum: ".concat(optionName, ": Unhandled type ").concat(_types.TypeDefInfo[def.info]));
  }
}

function tsPlain(_ref7, imports) {
  let {
    name: plainName,
    type
  } = _ref7;
  setImports(imports, [type]);
  return exportType(plainName, type);
}

function _tsStructGetterType(structName, _ref8, imports) {
  let {
    info,
    sub,
    type
  } = _ref8;

  let _type;

  switch (info) {
    case _types.TypeDefInfo.Compact:
      _type = sub.type;
      setImports(imports, ['Compact']);
      return [_type, "Compact<".concat(_type, ">")];

    case _types.TypeDefInfo.Option:
      _type = sub.type;
      setImports(imports, ['Option']);
      return [_type, "Option<".concat(_type, ">")];

    case _types.TypeDefInfo.Plain:
      return [type, type];

    case _types.TypeDefInfo.Vec:
      _type = sub.type;
      setImports(imports, ['Vec']);
      return [_type, "Vec<".concat(_type, ">")];

    default:
      throw new Error("Struct: ".concat(structName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsSet(_ref9, imports) {
  let {
    name: setName,
    sub
  } = _ref9;
  setImports(imports, ['Set']);
  const types = sub.map((_ref10) => {
    let {
      name
    } = _ref10;
    return createGetter("is".concat(name), 'boolean', imports);
  });
  return exportInterface(setName, 'Set', types.join(''));
}

function tsStruct(_ref11, imports) {
  let {
    name: structName,
    sub
  } = _ref11;
  const keys = sub.map(typedef => {
    const [embedType, returnType] = _tsStructGetterType(structName, typedef, imports);

    setImports(imports, ['Struct', embedType]);
    return createGetter(typedef.name, returnType, imports);
  });
  return exportInterface(structName, 'Struct', keys.join(''));
}

function _tsTupleGetterType(tupleName, _ref12, imports) {
  let {
    info,
    sub,
    type
  } = _ref12;

  switch (info) {
    case _types.TypeDefInfo.Option:
      setImports(imports, ['Option', sub.type]);
      return type;

    case _types.TypeDefInfo.Plain:
      setImports(imports, [type]);
      return type;

    default:
      throw new Error("Struct: ".concat(tupleName, ": Unhandled type ").concat(_types.TypeDefInfo[info]));
  }
}

function tsTuple(_ref13, imports) {
  let {
    name: tupleName,
    sub
  } = _ref13;
  setImports(imports, ['Codec', 'Tuple']);
  const types = sub.map(typedef => _tsTupleGetterType(tupleName, typedef, imports));
  return exportType(tupleName, "[".concat(types.join(', '), "] & Codec"));
}

function tsVec(_ref14, imports) {
  let {
    ext,
    info,
    name: vectorName,
    sub
  } = _ref14;
  const type = info === _types.TypeDefInfo.VecFixed ? ext.type : sub.type; // FIXME This should be a VecFixed
  // FIXME Technically Vec has length prefix, so for others this is not 100%

  if (info === _types.TypeDefInfo.VecFixed && type === 'u8') {
    setImports(imports, ['Codec']);
    return exportType(vectorName, 'Uint8Array & Codec');
  }

  setImports(imports, ['Vec', type]);
  return exportType(vectorName, "Vec<".concat(type, ">"));
} // creates the import lines


function createImportCode(header, checks) {
  return checks.reduce((result, _ref15) => {
    let {
      file,
      types
    } = _ref15;

    if (types.length) {
      result += "import { ".concat(types.sort().join(', '), " } from '").concat(file, "';\n");
    }

    return result;
  }, header) + '\n';
} // From `T`, generate `Compact<T>, Option<T>, Vec<T>`


function getDerivedTypes(type, primitiveName, imports) {
  let indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
  // `primitiveName` represents the actual primitive type our type is mapped to
  const isCompact = isCompactEncodable(primitiveClasses[primitiveName]);
  setImports(imports, ['Option', 'Vec', isCompact ? 'Compact' : '']);
  return ["".concat(type, ": ").concat(type, ";"), isCompact ? "'Compact<".concat(type, ">': Compact<").concat(type, ">;") : undefined, "'Option<".concat(type, ">': Option<").concat(type, ">;"), "'Vec<".concat(type, ">': Vec<").concat(type, ">;")].filter(x => !!x).map(line => "".concat(' '.repeat(indent)).concat(line)) // Add indentation
  .join('\n');
}

// Create an Imports object, prefilled with types (if necessary)
function createImports() {
  let {
    types
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    types: {}
  };
  // handlers are defined externally to use - this means that when we do a
  // `generators[typedef.info](...)` TS will show any unhandled types. Rather
  // we are being explicit in having no handlers where we do not support (yet)
  const generators = {
    [_types.TypeDefInfo.Compact]: tsCompact,
    [_types.TypeDefInfo.DoubleMap]: errorUnhandled,
    [_types.TypeDefInfo.Enum]: tsEnum,
    [_types.TypeDefInfo.Linkage]: errorUnhandled,
    [_types.TypeDefInfo.Null]: errorUnhandled,
    [_types.TypeDefInfo.Option]: tsOption,
    [_types.TypeDefInfo.Plain]: tsPlain,
    [_types.TypeDefInfo.Set]: tsSet,
    [_types.TypeDefInfo.Struct]: tsStruct,
    [_types.TypeDefInfo.Tuple]: tsTuple,
    [_types.TypeDefInfo.Vec]: tsVec,
    [_types.TypeDefInfo.VecFixed]: tsVec
  };
  const codecTypes = {};
  const localTypes = Object.keys(definitions).reduce((localTypes, moduleName) => {
    localTypes[moduleName] = {};
    return localTypes;
  }, {});
  const ownTypes = Object.keys(types);
  const primitiveTypes = {};
  const typesTypes = {};
  const interfaces = Object.entries(types).map((_ref16) => {
    let [name, type] = _ref16;
    const def = (0, _create.getTypeDef)((0, _util.isString)(type) ? type.toString() : JSON.stringify(type), name);
    return [name, generators[def.info](def, {
      codecTypes,
      localTypes,
      ownTypes,
      primitiveTypes,
      typesTypes
    })];
  });
  const imports = {
    codecTypes,
    localTypes,
    ownTypes,
    primitiveTypes,
    typesTypes,
    interfaces
  };
  return imports;
}

function generateTsDef(defName, _ref17) {
  let {
    types
  } = _ref17;
  const imports = createImports({
    types
  });
  const sortedDefs = imports.interfaces.sort((a, b) => a[0].localeCompare(b[0])).map((_ref18) => {
    let [, definition] = _ref18;
    return definition;
  }).join('\n\n');
  const header = createImportCode(HEADER, [{
    file: '../../types',
    types: Object.keys(imports.typesTypes)
  }, {
    file: '../../codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '../../primitive',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "../".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  }))]);
  Object.entries(imports.localTypes).forEach((_ref19) => {
    let [moduleName, typeMap] = _ref19;
    const types = Object.keys(typeMap).sort();

    if (types.length) {
      console.log("\timport { ".concat(types.join(', '), " } from '../").concat(moduleName, "'"));
    }
  });

  _fs.default.writeFileSync("packages/types/src/interfaces/".concat(defName, "/types.ts"), header.concat(sortedDefs).concat(FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync("packages/types/src/interfaces/".concat(defName, "/index.ts"), HEADER.concat('export * from \'./types\';').concat(FOOTER), {
    flag: 'w'
  });
} // Generate `packages/types/src/interfaceRegistry.ts`, the registry of all interfaces


function generateInterfaceRegistry() {
  const imports = createImports();
  const primitives = Object.keys(primitiveClasses).filter(name => !!name.indexOf('Generic')).reduce((accumulator, primitiveName) => {
    setImports(imports, [primitiveName]);
    return [accumulator, getDerivedTypes(primitiveName, primitiveName, imports)].join('\n');
  }, ''); // eslint-disable-next-line @typescript-eslint/no-unused-vars

  const srml = Object.entries(definitions).reduce((accumulator, _ref20) => {
    let [_defName, {
      types
    }] = _ref20;
    setImports(imports, Object.keys(types));
    return [accumulator, ...Object.keys(types).map(type => getDerivedTypes(type, types[type], imports, 2))].join('\n');
  }, '');
  const header = createImportCode(HEADER, [{
    file: './codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: './primitive',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "./interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  }))]);
  const interfaceStart = 'export interface InterfaceRegistry {';
  const interfaceEnd = '\n}';

  _fs.default.writeFileSync('packages/types/src/interfaceRegistry.ts', header.concat(interfaceStart).concat(primitives).concat(srml).concat(interfaceEnd).concat(FOOTER), {
    flag: 'w'
  });
} // Make types a little bit more flexible
// - if param instanceof AbstractInt, then param: u64 | Uint8array | string | number
// etc


function getSimilarTypes(imports, type) {
  const possibleTypes = [type];

  if (type === 'Extrinsic') {
    setImports(imports, ['IExtrinsic']);
    return ['IExtrinsic'];
  }

  if (isChildClass(_Vec.default, (0, _create.ClassOfUnsafe)(type))) {
    return ["(".concat(getSimilarTypes(imports, (0, _create.getTypeDef)(type).sub.type).join(' | '), ")[]")];
  } // FIXME This is a hack, it's hard to correctly type StorageKeys in the
  // current state


  if (type === 'StorageKey') {
    return ['any'];
  } // Cannot get isChildClass of abstract class, but it works


  if (isChildClass(_AbstractInt.default, (0, _create.ClassOfUnsafe)(type))) {
    possibleTypes.push('Uint8Array', 'number', 'string');
  } else if (isChildClass(Uint8Array, (0, _create.ClassOfUnsafe)(type))) {
    possibleTypes.push('Uint8Array', 'string');
  } else if (isChildClass(String, (0, _create.ClassOfUnsafe)(type))) {
    possibleTypes.push('string');
  }

  return possibleTypes;
} // Generate `packages/types-jsonrpc/src/jsonrpc.types.ts`


function generateRpcTypes() {
  // Inject all types so that types-jsonrpc can use them
  require('../injector'); // Get all imported types by types-jsonrpc


  const allImportedTypes = Object.keys(_src.default).reduce((allSections, section) => {
    return allSections.concat(...Object.values(_src.default[section].methods).map(method => [...method.params.map((_ref21) => {
      let {
        type
      } = _ref21;
      return type;
    }), method.type]));
  }, []);
  const imports = createImports({
    types: allImportedTypes
  });
  const body = Object.keys(_src.default).sort().reduce((allSections, section) => {
    const allMethods = Object.keys(_src.default[section].methods).sort().map(key => {
      const method = _src.default[section].methods[key]; // FIXME These 2 are too hard to type, I give up

      if (method.method === 'getStorage') {
        setImports(imports, ['Codec']);
        return '    getStorage<T = Codec>(key: any, block?: Hash | Uint8Array | string): Observable<T>;';
      } else if (method.method === 'subscribeStorage') {
        return '    subscribeStorage<T = Codec[]>(keys: any[]): Observable<T>;';
      }

      const args = method.params.map(param => {
        const similarTypes = getSimilarTypes(imports, param.type);
        setImports(imports, similarTypes);
        return "".concat(param.name).concat(param.isOptional ? '?' : '', ": ").concat(similarTypes.join(' | '));
      });
      return "    ".concat(method.method, "(").concat(args.join(', '), "): Observable<").concat(method.type, ">;");
    });
    return allSections.concat(["  ".concat(section, ": {"), ...allMethods, '  };'].join('\n'));
  }, []).join('\n');
  const header = createImportCode(HEADER, [{
    file: 'rxjs',
    types: ['Observable']
  }, {
    file: '@plugnet/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@plugnet/types',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@plugnet/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  })), {
    file: '@plugnet/types/types',
    types: Object.keys(imports.typesTypes)
  }]);
  const interfaceStart = 'export interface RpcInterface {\n';
  const interfaceEnd = '\n}';

  _fs.default.writeFileSync('packages/rpc-core/src/jsonrpc.types.ts', header.concat(interfaceStart).concat(body).concat(interfaceEnd).concat(FOOTER), {
    flag: 'w'
  });
}

function main() {
  Object.entries(definitions).forEach((_ref22) => {
    let [defName, obj] = _ref22;
    console.log("Extracting interfaces for ".concat(defName));
    generateTsDef(defName, obj);
  });
  console.log('Writing interfaces/types.ts');

  _fs.default.writeFileSync('packages/types/src/interfaces/types.ts', HEADER.concat(Object.keys(definitions).map(moduleName => "export * from './".concat(moduleName, "/types';")).join('\n')).concat(FOOTER), {
    flag: 'w'
  });

  _fs.default.writeFileSync('packages/types/src/interfaces/index.ts', HEADER.concat('export * from \'./types\';').concat(FOOTER), {
    flag: 'w'
  });

  console.log('Writing interfaceRegistry.ts');
  generateInterfaceRegistry();
  console.log('Writing packages/rpc-core/jsonrpc.types.ts');
  generateRpcTypes();
}

main();