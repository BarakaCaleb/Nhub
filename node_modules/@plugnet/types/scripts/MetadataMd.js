"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("../injector");

var _fs = _interopRequireDefault(require("fs"));

var _util = require("@plugnet/util");

var _src = _interopRequireDefault(require("../../../type-jsonrpc/src"));

var _Call = _interopRequireDefault(require("../primitive/Generic/Call"));

var _Metadata = _interopRequireDefault(require("../Metadata"));

var _static = _interopRequireDefault(require("../Metadata/static"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const ANCHOR_TOP = '';
const LINK_BACK_TO_TOP = '';
const DESC_CONSTANTS = '\n\n_The following sections contain the module constants, also known as parameter types.\n';
const DESC_EXTRINSICS = '\n\n_The following sections contain Extrinsics methods are part of the default Substrate runtime._\n';
const DESC_EVENTS = '\n\nEvents are emitted for certain operations on the runtime. The following sections describe the events that are part of the default Substrate runtime.\n';
const DESC_RPC = '\n\n_The following sections contain RPC methods that are Remote Calls available by default and allow you to interact with the actual node, query, and submit. The RPCs are provided by Substrate itself._';
const DESC_STORAGE = '\n\n_The following sections contain Storage methods are part of the default Substrate runtime._\n';

function sectionLink(sectionName) {
  return "- **[".concat((0, _util.stringCamelCase)(sectionName), "](#").concat((0, _util.stringCamelCase)(sectionName), ")**\n\n");
}

function generateSectionHeader(md, sectionName) {
  return "".concat(md, "\n___\n").concat(LINK_BACK_TO_TOP, "\n\n### ").concat(sectionName, "\n");
}

function addRpc() {
  const renderHeading = "## ".concat(ANCHOR_TOP, "JSON-RPC").concat(DESC_RPC, "\n");
  const orderedSections = Object.keys(_src.default).sort();
  const renderAnchors = Object.keys(_src.default).sort().map(sectionName => sectionLink(sectionName)).join('');
  return orderedSections.reduce((md, sectionName) => {
    const section = _src.default[sectionName];
    const renderSection = generateSectionHeader(md, sectionName) + "\n_".concat(section.description, "_\n");
    const orderedMethods = Object.keys(section.methods).sort();
    return orderedMethods.reduce((md, methodName) => {
      const method = section.methods[methodName];
      const args = method.params.map((_ref) => {
        let {
          name,
          isOptional,
          type
        } = _ref;
        return name + (isOptional ? '?' : '') + ': `' + type + '`';
      }).join(', ');
      const type = '`' + method.type + '`'; // const isSub = method.isSubscription;

      const renderMethod = "".concat(md, "\n\u25B8 **").concat(methodName, "**(").concat(args, ")");
      const renderReturnType = ": ".concat(type);
      const renderSignature = "".concat(renderMethod).concat(renderReturnType);
      const renderSummary = "".concat(method && method.description ? "\n- **summary**: ".concat(method.description, "\n") : '\n\n');
      return "".concat(renderSignature).concat(renderSummary);
    }, renderSection);
  }, renderHeading + renderAnchors);
}
/**
 * Sort object by their `.name`
 */


function sortByName(a, b) {
  // ignore upper and lowercase
  const nameA = a.name.toString().toUpperCase();
  const nameB = b.name.toString().toUpperCase();
  return nameA.localeCompare(nameB);
}

function addConstants(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Constants").concat(DESC_CONSTANTS);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, moduleMetadata) => {
    if (moduleMetadata.constants.isEmpty) {
      return md;
    }

    const sectionName = (0, _util.stringLowerFirst)(moduleMetadata.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedConstants = moduleMetadata.constants.sort(sortByName);
    return orderedConstants.reduce((md, func) => {
      const methodName = (0, _util.stringCamelCase)(func.name.toString());
      const doc = func.documentation.reduce((md, doc) => "".concat(md, " ").concat(doc), '');
      const type = func.type;
      const renderSignature = "".concat(md, "\n\u25B8 **").concat(methodName, "**: ") + '`' + type + '`';
      const renderSummary = "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
      return renderSignature + renderSummary;
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addEvents(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Events").concat(DESC_EVENTS);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, meta) => {
    if (meta.events.isNone || !meta.events.unwrap().length) {
      return md;
    }

    const events = meta.events.unwrap();
    const sectionName = (0, _util.stringCamelCase)(meta.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = events.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const methodName = func.name.toString();
      const args = func.args.map(type => '`' + type + '`').join(', ');
      const doc = func.documentation.reduce((md, doc) => "".concat(md, " ").concat(doc), '');
      const renderSignature = "".concat(md, "\n\u25B8 **").concat(methodName, "**(").concat(args, ")");
      const renderSummary = "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
      return renderSignature + renderSummary;
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addExtrinsics(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Extrinsics").concat(DESC_EXTRINSICS);
  const orderedSections = metadata.modules.map(i => i).sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, meta) => {
    if (meta.calls.isNone || !meta.calls.unwrap().length) {
      return md;
    }

    const calls = meta.calls.unwrap();
    const sectionName = (0, _util.stringCamelCase)(meta.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = calls.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const methodName = (0, _util.stringCamelCase)(func.name.toString());

      const args = _Call.default.filterOrigin(func).map((_ref2) => {
        let {
          name,
          type
        } = _ref2;
        return "".concat(name, ": ") + '`' + type + '`';
      }).join(', ');

      const doc = func.documentation.reduce((md, doc) => "".concat(md, " ").concat(doc), '');
      const renderSignature = "".concat(md, "\n\u25B8 **").concat(methodName, "**(").concat(args, ")");
      const renderSummary = "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
      return renderSignature + renderSummary;
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addStorage(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Storage").concat(DESC_STORAGE);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, moduleMetadata) => {
    if (moduleMetadata.storage.isNone) {
      return md;
    }

    const sectionName = (0, _util.stringLowerFirst)(moduleMetadata.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = moduleMetadata.storage.unwrap().items.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const arg = func.type.isMap ? '`' + func.type.asMap.key.toString() + '`' : func.type.isDoubleMap ? '`' + func.type.asDoubleMap.key1.toString() + ', ' + func.type.asDoubleMap.key2.toString() + '`' : '';
      const doc = func.documentation.reduce((md, doc) => "".concat(md, " ").concat(doc), '');
      let result = (func.type.isDoubleMap ? func.type.asDoubleMap.value : func.type).toString();

      if (func.modifier.isOptional) {
        result = "Option<".concat(result, ">");
      }

      return "".concat(md, "\n\u25B8 **").concat((0, _util.stringLowerFirst)(func.name.toString()), "**(").concat(arg, "): ") + '`' + result + '`' + "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sectionLink('substrate') + sections;
}

function writeFile(name) {
  const options = {
    flags: 'w',
    encoding: 'utf8'
  };

  const writeStream = _fs.default.createWriteStream(name, options);

  writeStream.on('finish', () => {
    console.log("Completed writing ".concat(name));
  });

  for (var _len = arguments.length, chunks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    chunks[_key - 1] = arguments[_key];
  }

  chunks.forEach(chunk => {
    writeStream.write(chunk);
  });
  writeStream.end();
}

function writeToRpcMd() {
  writeFile('docs/METHODS_RPC.md', addRpc());
}

function writeToConstantsMd(metadata) {
  writeFile('docs/METHODS_CONSTANTS.md', addConstants(metadata));
}

function writeToStorageMd(metadata) {
  const options = {
    flags: 'r',
    encoding: 'utf8'
  };

  const data = _fs.default.readFileSync('packages/types/src/scripts/METHODS_STORAGE_SUBSTRATE.md', options);

  writeFile('docs/METHODS_STORAGE.md', addStorage(metadata), data);
}

function writeToExtrinsicsMd(metadata) {
  writeFile('docs/METHODS_EXTRINSICS.md', addExtrinsics(metadata));
}

function writeToEventsMd(metadata) {
  writeFile('docs/METHODS_EVENTS.md', addEvents(metadata));
}

const metadata = new _Metadata.default(_static.default).asLatest;
writeToRpcMd();
writeToConstantsMd(metadata);
writeToStorageMd(metadata);
writeToExtrinsicsMd(metadata);
writeToEventsMd(metadata);