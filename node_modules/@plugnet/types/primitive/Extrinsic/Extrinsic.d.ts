import { FunctionMetadataV7 } from '../../interfaces/metadata/types';
import { Address, Balance, Call, ExtrinsicUnknown, ExtrinsicV1, ExtrinsicV2, ExtrinsicV3, Index } from '../../interfaces/runtime';
import { AnyU8a, ArgsDef, Codec, ExtrinsicPayloadValue, IExtrinsic, IHash, IKeyringPair, SignatureOptions } from '../../types';
import Base from '../../codec/Base';
import Compact from '../../codec/Compact';
import { ExtrinsicValueV1 } from './v1/Extrinsic';
import { ExtrinsicValueV2 } from './v2/Extrinsic';
import { ExtrinsicValueV3 } from './v3/Extrinsic';
import ExtrinsicEra from './ExtrinsicEra';
declare type ExtrinsicVx = ExtrinsicV1 | ExtrinsicV2 | ExtrinsicV3;
declare type ExtrinsicValue = ExtrinsicValueV1 | ExtrinsicValueV2 | ExtrinsicValueV3;
interface CreateOptions {
    version?: number;
}
/**
 * @name Extrinsic
 * @description
 * Representation of an Extrinsic in the system. It contains the actual call,
 * (optional) signature and encodes with an actual length prefix
 *
 * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.
 *
 * Can be:
 * - signed, to create a transaction
 * - left as is, to create an inherent
 */
export default class Extrinsic extends Base<ExtrinsicVx | ExtrinsicUnknown> implements IExtrinsic {
    constructor(value: Extrinsic | ExtrinsicValue | AnyU8a | Call | undefined, { version }?: CreateOptions);
    private static newFromValue;
    static decodeExtrinsic(value: Extrinsic | ExtrinsicValue | AnyU8a | Call | undefined, version?: number): ExtrinsicVx | ExtrinsicUnknown;
    private static decodeU8aLike;
    private static decodeU8a;
    /**
     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]
     */
    readonly args: Codec[];
    /**
     * @description Thge argument defintions, compatible with [[Call]]
     */
    readonly argsDef: ArgsDef;
    /**
     * @description The actual `[sectionIndex, methodIndex]` as used in the Call
     */
    readonly callIndex: Uint8Array;
    /**
     * @description The actual data for the Call
     */
    readonly data: Uint8Array;
    /**
     * @description The era for thios extrinsic
     */
    readonly era: ExtrinsicEra;
    /**
     * @description The length of the value when encoded as a Uint8Array
     */
    readonly encodedLength: number;
    /**
     * @description `true` is method has `Origin` argument (compatibility with [Call])
     */
    readonly hasOrigin: boolean;
    /**
     * @description `true` id the extrinsic is signed
     */
    readonly isSigned: boolean;
    /**
     * @description The length of the actual data, excluding prefix
     */
    readonly length: number;
    /**
     * @description The [[FunctionMetadataV7]] that describes the extrinsic
     */
    readonly meta: FunctionMetadataV7;
    /**
     * @description The [[Call]] this extrinsic wraps
     */
    readonly method: Call;
    /**
     * @description The nonce for this extrinsic
     */
    readonly nonce: Compact<Index>;
    /**
     * @description The [[ExtrinsicSignature]]
     */
    readonly signature: IHash;
    /**
     * @description The [[Address]] that signed
     */
    readonly signer: Address;
    /**
     * @description Forwards compat
     */
    readonly tip: Compact<Balance>;
    /**
     * @description Returns the raw transaction version (not flagged with signing information)
    */
    readonly type: number;
    /**
     * @description Returns the encoded version flag
    */
    readonly version: number;
    /**
     * @description Injects an already-generated signature into the extrinsic
     */
    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, ...args: [ExtrinsicPayloadValue | Uint8Array | string]): Extrinsic;
    /**
     * @description Sign the extrinsic with a specific keypair
     */
    sign(account: IKeyringPair, options: SignatureOptions): Extrinsic;
    /**
     * @description Returns a hex string representation of the value
     */
    toHex(): string;
    /**
     * @description Converts the Object to JSON, typically used for RPC transfers
     */
    toJSON(): string;
    /**
     * @description Returns the base runtime type name for this instance
     */
    toRawType(): string;
    /**
     * @description Encodes the value as a Uint8Array as per the SCALE specifications
     * @param isBare true when the value has none of the type-specific prefixes (internal)
     */
    toU8a(isBare?: boolean): Uint8Array;
}
export {};
