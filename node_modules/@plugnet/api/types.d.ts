import { Hash, RuntimeVersion } from '@plugnet/types/interfaces';
import { AnyFunction, Callback, CallFunction, Codec, CodecArg, RegistryTypes, SignatureOptions, SignerPayloadJSON, SignerPayloadRaw } from '@plugnet/types/types';
import { SubmittableResultImpl, SubmittableExtrinsic } from './submittable/types';
import BN from 'bn.js';
import { Observable } from 'rxjs';
import { DeriveCustom } from '@plugnet/api-derive';
import { Constants } from '@plugnet/api-metadata/consts/types';
import { RpcInterface } from '@plugnet/rpc-core/jsonrpc.types';
import { ProviderInterface, ProviderInterfaceEmitted } from '@plugnet/rpc-provider/types';
import { Metadata, u64 } from '@plugnet/types';
import { StorageEntry } from '@plugnet/types/primitive/StorageKey';
import ApiBase from './base';
export * from './submittable/types';
declare type Cons<V, T extends any[]> = ((v: V, ...t: T) => void) extends ((...r: infer R) => void) ? R : never;
declare type Push<T extends any[], V> = ((Cons<any, Required<T>> extends infer R ? {
    [K in keyof R]: K extends keyof T ? T[K] : V;
} : never) extends infer P ? P extends any[] ? P : never : never);
export declare type ObsInnerType<O extends Observable<any>> = O extends Observable<infer U> ? U : never;
export declare type UnsubscribePromise = Promise<() => void>;
export interface DecorateMethodOptions {
    methodName?: string;
}
export declare type DecorateMethod = (method: (...args: any[]) => Observable<any>, options?: DecorateMethodOptions) => any;
export declare type RxResult<F extends AnyFunction> = (...args: Parameters<F>) => Observable<ObsInnerType<ReturnType<F>>>;
export interface PromiseResult<F extends AnyFunction> {
    (...args: Parameters<F>): Promise<ObsInnerType<ReturnType<F>>>;
    (...args: Push<Parameters<F>, Callback<ObsInnerType<ReturnType<F>>>>): UnsubscribePromise;
    <T>(...args: Parameters<F>): Promise<T>;
    <T>(...args: Push<Parameters<F>, Callback<T>>): UnsubscribePromise;
}
export declare type MethodResult<ApiType, F extends AnyFunction> = ApiType extends 'rxjs' ? RxResult<F> : PromiseResult<F>;
export declare type DecoratedRpcSection<ApiType, Section> = {
    [Method in keyof Section]: Section[Method] extends AnyFunction ? MethodResult<ApiType, Section[Method]> : never;
};
export declare type DecoratedRpc<ApiType, AllSections> = {
    [Section in keyof AllSections]: DecoratedRpcSection<ApiType, AllSections[Section]>;
};
interface StorageEntryBase<C, H, U> {
    at: (hash: Hash | Uint8Array | string, arg1?: CodecArg, arg2?: CodecArg) => C;
    creator: StorageEntry;
    hash: (arg1?: CodecArg, arg2?: CodecArg) => H;
    key: (arg1?: CodecArg, arg2?: CodecArg) => string;
    size: (arg1?: CodecArg, arg2?: CodecArg) => U;
}
export interface StorageEntryObservable extends StorageEntryBase<Observable<Codec>, Observable<Hash>, Observable<u64>> {
    (arg1?: CodecArg, arg2?: CodecArg): Observable<Codec>;
    <T extends Codec>(arg1?: CodecArg, arg2?: CodecArg): Observable<T>;
    multi: <T extends Codec>(args: (CodecArg[] | CodecArg)[]) => Observable<T[]>;
}
export interface StorageEntryPromiseOverloads {
    (arg1?: CodecArg, arg2?: CodecArg): Promise<Codec>;
    <T extends Codec>(arg1?: CodecArg, arg2?: CodecArg): Promise<T>;
    <T extends Codec>(callback: Callback<T>): UnsubscribePromise;
    <T extends Codec>(arg: CodecArg, callback: Callback<T>): UnsubscribePromise;
    <T extends Codec>(arg1: CodecArg, arg2: CodecArg, callback: Callback<T>): UnsubscribePromise;
}
export interface StorageEntryPromiseMulti {
    <T extends Codec>(args: (CodecArg[] | CodecArg)[]): Promise<T[]>;
    <T extends Codec>(args: (CodecArg[] | CodecArg)[], callback: Callback<T[]>): UnsubscribePromise;
}
export interface StorageEntryPromise extends StorageEntryBase<Promise<Codec>, Promise<Hash>, Promise<u64>>, StorageEntryPromiseOverloads {
    multi: StorageEntryPromiseMulti;
}
export declare type QueryableStorageEntry<ApiType> = ApiType extends 'rxjs' ? StorageEntryObservable : StorageEntryPromise;
export interface QueryableModuleStorage<ApiType> {
    [index: string]: QueryableStorageEntry<ApiType>;
}
export declare type QueryableStorageMultiArg<ApiType> = QueryableStorageEntry<ApiType> | [QueryableStorageEntry<ApiType>, ...CodecArg[]];
export declare type QueryableStorageMultiArgs<ApiType> = QueryableStorageMultiArg<ApiType>[];
export interface QueryableStorageMultiBase<ApiType> {
    <T extends Codec>(calls: QueryableStorageMultiArgs<ApiType>): Observable<T[]>;
}
export interface QueryableStorageMultiPromise<ApiType> {
    <T extends Codec>(calls: QueryableStorageMultiArgs<ApiType>, callback: Callback<T[]>): UnsubscribePromise;
}
export declare type QueryableStorageMulti<ApiType> = ApiType extends 'rxjs' ? QueryableStorageMultiBase<ApiType> : QueryableStorageMultiPromise<ApiType>;
export interface QueryableStorage<ApiType> {
    [index: string]: QueryableModuleStorage<ApiType>;
}
export interface SubmittableExtrinsicFunction<ApiType> extends CallFunction {
    (...params: CodecArg[]): SubmittableExtrinsic<ApiType>;
}
export interface SubmittableModuleExtrinsics<ApiType> {
    [index: string]: SubmittableExtrinsicFunction<ApiType>;
}
export interface SubmittableExtrinsics<ApiType> {
    (extrinsic: Uint8Array | string): SubmittableExtrinsic<ApiType>;
    [index: string]: SubmittableModuleExtrinsics<ApiType>;
}
export interface ApiOptions {
    /**
     * @description Add custom derives to be injected
     */
    derives?: DeriveCustom;
    /**
     * @description prebundles is a map of 'genesis hash and runtime spec version' as key to metadata's hex string
     * if genesis hash and runtime spec version matches, then use metadata, else fetch it from chain
     */
    metadata?: Record<string, string>;
    /**
     * @description Transport Provider from rpc-provider. If not specified, it will default to
     * connecting to a WsProvider connecting localhost with the default port, i.e. `ws://127.0.0.1:9944`
     */
    provider?: ProviderInterface;
    /**
     * @description An external signer which will be used to sign extrinsic when account passed in is not KeyringPair
     */
    signer?: Signer;
    /**
     * @description The source object to use for runtime information (only used when cloning)
     */
    source?: ApiBase<any>;
    /**
     * @description Additional types used by runtime modules. This is nessusary if the runtime modules
     * uses types not available in the base Substrate runtime.
     */
    types?: RegistryTypes;
    /**
     * @description Additional types that are injected based on the chain we are connecting to. There are keyed by the chain, i.e. `{ 'Kusama CC1': { ... } }`
     */
    typesChain?: Record<string, RegistryTypes>;
    /**
     * @description Additional types that are injected based on the type of node we are connecting to, as set via specName in the runtime version. There are keyed by the node, i.e. `{ 'edgeware': { ... } }`
     */
    typesSpec?: Record<string, RegistryTypes>;
}
export interface ApiInterfaceRx {
    consts: Constants;
    extrinsicType: number;
    genesisHash: Hash;
    hasSubscriptions: boolean;
    runtimeMetadata: Metadata;
    runtimeVersion: RuntimeVersion;
    query: QueryableStorage<'rxjs'>;
    queryMulti: QueryableStorageMulti<'rxjs'>;
    rpc: DecoratedRpc<'rxjs', RpcInterface>;
    tx: SubmittableExtrinsics<'rxjs'>;
    signer?: Signer;
}
export declare type ApiInterfaceEvents = ProviderInterfaceEmitted | 'ready';
export declare type ApiTypes = 'promise' | 'rxjs';
export interface SignerOptions extends SignatureOptions {
    blockNumber: BN;
    genesisHash: Hash;
}
export interface SignerResult {
    /**
     * @description The id for this request
     */
    id: number;
    /**
     * @description The resulting signature in hex
     */
    signature: string;
}
export interface Signer {
    /**
     * @description signs an extrinsic payload from a serialized form
     */
    signPayload?: (payload: SignerPayloadJSON) => Promise<SignerResult>;
    /**
     * @description signs a raw payload, only the bytes data as supplied
     */
    signRaw?: (raw: SignerPayloadRaw) => Promise<SignerResult>;
    /**
     * @description Receives an update for the extrinsic signed by a `signer.sign`
     */
    update?: (id: number, status: Hash | SubmittableResultImpl) => void;
}
