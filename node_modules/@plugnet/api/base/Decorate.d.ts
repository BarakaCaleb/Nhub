import { RpcInterface } from '@plugnet/rpc-core/jsonrpc.types';
import { Hash, RuntimeVersion } from '@plugnet/types/interfaces';
import { AnyFunction, ModulesWithCalls } from '@plugnet/types/types';
import { ApiInterfaceRx, ApiOptions, ApiTypes, DecorateMethod, DecoratedRpc, QueryableStorage, QueryableStorageMulti, SubmittableExtrinsics } from '../types';
import BN from 'bn.js';
import { BehaviorSubject, Observable } from 'rxjs';
import { Constants } from '@plugnet/api-metadata/consts/types';
import { Storage } from '@plugnet/api-metadata/storage/types';
import RpcCore from '@plugnet/rpc-core';
import { Metadata } from '@plugnet/types';
import Events from './Events';
export default abstract class Decorate<ApiType> extends Events {
    protected __phantom: BN;
    protected _consts?: Constants;
    protected _derive?: ReturnType<Decorate<ApiType>['decorateDerive']>;
    protected _extrinsics?: SubmittableExtrinsics<ApiType>;
    protected _extrinsicType: number;
    protected _genesisHash?: Hash;
    protected _isConnected: BehaviorSubject<boolean>;
    protected _isReady: boolean;
    protected readonly _options: ApiOptions;
    protected _query?: QueryableStorage<ApiType>;
    protected _queryMulti?: QueryableStorageMulti<ApiType>;
    protected _rpc?: DecoratedRpc<ApiType, RpcInterface>;
    protected _rpcCore: RpcCore;
    protected _runtimeMetadata?: Metadata;
    protected _runtimeVersion?: RuntimeVersion;
    protected _rx: Partial<ApiInterfaceRx>;
    protected _type: ApiTypes;
    /**
     * This is the one and only method concrete children classes need to implement.
     * It's a higher-order function, which takes one argument
     * `method: Method extends (...args: any[]) => Observable<any>`
     * (and one optional `options`), and should return the user facing method.
     * For example:
     * - For ApiRx, `decorateMethod` should just be identity, because the input
     * function is already an Observable
     * - For ApiPromise, `decorateMethod` should return a function that takes all
     * the parameters from `method`, adds an optional `callback` argument, and
     * returns a Promise.
     *
     * We could easily imagine other user-facing interfaces, which are simply
     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
     * via `deocrateMethod`.
     */
    protected decorateMethod: DecorateMethod;
    /**
     * @description Create an instance of the class
     *
     * @param options Options object to create API instance or a Provider instance
     *
     * @example
     * <BR>
     *
     * ```javascript
     * import Api from '@plugnet/api/promise';
     *
     * const api = new Api().isReady();
     *
     * api.rpc.subscribeNewHeads((header) => {
     *   console.log(`new block #${header.number.toNumber()}`);
     * });
     * ```
     */
    constructor(options: ApiOptions, type: ApiTypes, decorateMethod: DecorateMethod);
    private decorateFunctionMeta;
    protected decorateRpc<ApiType>(rpc: RpcCore, decorateMethod: Decorate<ApiType>['decorateMethod']): DecoratedRpc<ApiType, RpcInterface>;
    protected decorateMulti<ApiType>(decorateMethod: Decorate<ApiType>['decorateMethod']): QueryableStorageMulti<ApiType>;
    protected decorateExtrinsics<ApiType>(extrinsics: ModulesWithCalls, decorateMethod: Decorate<ApiType>['decorateMethod']): SubmittableExtrinsics<ApiType>;
    private decorateExtrinsicEntry;
    protected decorateStorage<ApiType>(storage: Storage, decorateMethod: Decorate<ApiType>['decorateMethod']): QueryableStorage<ApiType>;
    private decorateStorageEntry;
    private decorateStorageEntryLinked;
    protected decorateDerive(apiRx: ApiInterfaceRx, decorateMethod: Decorate<ApiType>['decorateMethod']): {
        accounts: {
            idAndIndex: import("../types").MethodResult<ApiType, (address?: string | import("../../../types/src").GenericAccountId | import("../../../types/src").GenericAccountIndex | import("../../../types/src").GenericAddress | null | undefined) => Observable<[(import("../../../types/src").GenericAccountId | undefined)?, (import("../../../types/src").GenericAccountIndex | undefined)?]>>;
            idToIndex: import("../types").MethodResult<ApiType, (accountId: string | import("../../../types/src").GenericAccountId) => Observable<import("../../../types/src").GenericAccountIndex | undefined>>;
            indexToId: import("../types").MethodResult<ApiType, (accountIndex: string | import("../../../types/src").GenericAccountIndex) => Observable<import("../../../types/src").GenericAccountId | undefined>>;
            indexes: import("../types").MethodResult<ApiType, () => Observable<Record<string, import("../../../types/src").GenericAccountIndex>>>;
        };
        balances: {
            all: import("../types").MethodResult<ApiType, (address: string | import("../../../types/src").GenericAccountId | import("../../../types/src").GenericAccountIndex | import("../../../types/src").GenericAddress) => Observable<import("../../../api-derive/src/types").DerivedBalances>>;
            votingBalance: import("../types").MethodResult<ApiType, (address: string | import("../../../types/src").GenericAccountId | import("../../../types/src").GenericAccountIndex | import("../../../types/src").GenericAddress) => Observable<import("../../../api-derive/src/types").DerivedBalances>>;
            fees: import("../types").MethodResult<ApiType, () => Observable<import("../../../api-derive/src/types").DerivedFees>>;
            votingBalances: import("../types").MethodResult<ApiType, (addresses?: (string | import("../../../types/src").GenericAccountId | import("../../../types/src").GenericAccountIndex | import("../../../types/src").GenericAddress)[] | undefined) => Observable<import("../../../api-derive/src/types").DerivedBalances[]>>;
            votingBalancesNominatorsFor: import("../types").MethodResult<ApiType, (address: string | import("../../../types/src").GenericAccountId | import("../../../types/src").GenericAccountIndex | import("../../../types/src").GenericAddress) => Observable<import("../../../api-derive/src/types").DerivedBalances[]>>;
        };
        chain: {
            bestNumber: import("../types").MethodResult<ApiType, () => Observable<import("../../../types/src").u32>>;
            bestNumberFinalized: import("../types").MethodResult<ApiType, () => Observable<import("../../../types/src").u32>>;
            bestNumberLag: import("../types").MethodResult<ApiType, () => Observable<import("../../../types/src").u32>>;
            getHeader: import("../types").MethodResult<ApiType, (hash: string | Uint8Array) => Observable<import("../../../api-derive/src").HeaderExtended | undefined>>;
            subscribeNewHeads: import("../types").MethodResult<ApiType, () => Observable<import("../../../api-derive/src").HeaderExtended>>;
        };
        contracts: {
            fees: import("../types").MethodResult<ApiType, () => Observable<import("../../../api-derive/src/types").DerivedContractFees>>;
        };
        democracy: {
            referendumInfos: import("../types").MethodResult<ApiType, (ids?: (number | BN)[] | undefined) => Observable<import("../../../types/src").Option<import("../../../api-derive/src").ReferendumInfoExtended>[]>>;
            referendums: import("../types").MethodResult<ApiType, () => Observable<import("../../../types/src").Option<import("../../../api-derive/src").ReferendumInfoExtended>[]>>;
            referendumVotesFor: import("../types").MethodResult<ApiType, (referendumId: number | BN) => Observable<import("../../../api-derive/src/types").DerivedReferendumVote[]>>;
            votes: import("../types").MethodResult<ApiType, (referendumId: BN, accountIds?: import("../../../types/src").GenericAccountId[] | undefined) => Observable<import("../../../types/src").GenericVote[]>>;
        };
        elections: {
            approvalsOf: import("../types").MethodResult<ApiType, (who: import("../../../types/src").GenericAccountId) => Observable<boolean[][]>>;
            approvalsOfAt: import("../types").MethodResult<ApiType, (who: import("../../../types/src").GenericAccountId, at: import("../../../types/src").u32) => Observable<boolean[]>>;
            info: import("../types").MethodResult<ApiType, () => Observable<import("../../../api-derive/src/types").DerivedElectionsInfo>>;
            voters: import("../types").MethodResult<ApiType, () => Observable<import("../../../types/src").Vec<import("../../../types/src").GenericAccountId>>>;
            voterPositions: import("../types").MethodResult<ApiType, () => Observable<Record<string, import("../../../api-derive/src/types").VoterPosition>>>;
        };
        imOnline: {
            receivedHeartbeats: import("../types").MethodResult<ApiType, (addresses: (string | import("../../../types/src").GenericAccountId)[]) => Observable<boolean[]>>;
        };
        session: {
            eraLength: import("../types").MethodResult<ApiType, () => Observable<BN>>;
            eraProgress: import("../types").MethodResult<ApiType, () => Observable<BN>>;
            info: import("../types").MethodResult<ApiType, () => Observable<import("../../../api-derive/src/types").DerivedSessionInfo>>;
            sessionProgress: import("../types").MethodResult<ApiType, () => Observable<BN>>;
        };
        staking: {
            controllers: import("../types").MethodResult<ApiType, () => Observable<[import("../../../types/src").GenericAccountId[], import("../../../types/src").Option<import("../../../types/src").GenericAccountId>[]]>>;
            info: import("../types").MethodResult<ApiType, (_accountId: string | Uint8Array) => Observable<import("../../../api-derive/src/types").DerivedStaking>>;
            recentlyOffline: import("../types").MethodResult<ApiType, () => Observable<Record<string, import("../../../api-derive/src/types").RecentlyOffline[]>>>;
        };
    };
    /**
     * Put the `this.onCall` function of ApiRx here, because it is needed by
     * `api._rx`.
     */
    protected rxDecorateMethod: <Method extends AnyFunction>(method: Method) => Method;
}
